
// This file now contains core type definitions that are NOT dependent on i18n data.
// Definitions that rely on labels from JSON (like SIZES, ALIGNMENTS array constants)
// will be generated by the I18nProvider and accessed via context.

export type AbilityName = 'strength' | 'dexterity' | 'constitution' | 'intelligence' | 'wisdom' | 'charisma' | 'none';

export interface AbilityScores {
  strength: number;
  dexterity: number;
  constitution: number;
  intelligence: number;
  wisdom: number;
  charisma: number;
}

export interface CharacterClass {
  id: string;
  className: DndClassId | ''; // kebab-case ID
  level: number;
}

export interface CustomSynergyRule {
  id: string;
  targetSkillName: string; // Skill ID
  ranksInThisSkillRequired: number;
  bonusGranted: number;
}

export interface Skill {
  id: string;
  ranks: number;
  miscModifier: number;
  isClassSkill?: boolean;
}

export interface FeatPrerequisiteDetails {
  bab?: number;
  abilities?: Partial<Record<Exclude<AbilityName, 'none'>, number>>;
  skills?: Array<{ id: string; ranks: number }>;
  feats?: string[];
  casterLevel?: number;
  classLevel?: { classId: DndClassId | string; level: number };
  raceId?: DndRaceId | string;
  alignment?: string; // This might be a specific alignment value or a generic one like "lawful"
  special?: string;
}

// New structured feat effects
export interface SkillEffectDetail {
  type: "skill";
  skillId: string | null; // null for specialization
  value: number;
  bonusType?: "competence" | "circumstance" | "racial" | "untyped";
  condition?: string; // Plain text
}

export interface NoteEffectDetail {
  type: "note";
  text: string;
  // targetCategory?: "AC" | "SavingThrow" | "AttackRoll" | "DamageRoll" etc. for future categorization
}

export interface AbilityScoreEffect {
  type: "abilityScore";
  ability: Exclude<AbilityName, 'none'>;
  value: number;
  bonusType?: "enhancement" | "inherent" | "morale" | "competence" | "circumstance" | "size" | "untyped";
  condition?: string;
  sourceFeat?: string; // Added for tracing where the effect came from during aggregation
}

// Add other specific effect detail types here in the future:
// export interface AttackRollEffect { type: "attackRoll"; ... }
// export interface DamageRollEffect { type: "damageRoll"; ... }
// ... and so on

export type FeatEffectDetail = SkillEffectDetail | NoteEffectDetail | AbilityScoreEffect; // Added AbilityScoreEffect

export type FeatTypeString = string; // Will be defined by FEAT_TYPES_DATA from JSON

export interface FeatDefinitionJsonData { // Base structure for feat definitions
  value: string;
  label: string;
  description?: string;
  prerequisites?: FeatPrerequisiteDetails;
  effectsText?: string; // General textual summary of all effects
  effects?: FeatEffectDetail[]; // Array of structured effects
  canTakeMultipleTimes?: boolean;
  requiresSpecialization?: string; // e.g., "skill", "weapon", "school of magic"
  type?: FeatTypeString;
  isClassFeature?: boolean;
  isCustom?: boolean;
}


export interface CharacterFeatInstance {
  definitionId: string;
  instanceId: string;
  specializationDetail?: string; // e.g., the skillId for Skill Focus, weapon name for Weapon Focus
  isGranted?: boolean;
  grantedNote?: string;
}

export interface Item {
  id: string;
  name: string;
  quantity: number;
  description?: string;
  weight?: number;
}

export type SavingThrowType = 'fortitude' | 'reflex' | 'will';

export interface SingleSavingThrow {
  base: number;
  magicMod: number;
  miscMod: number;
}
export interface SavingThrows {
  fortitude: SingleSavingThrow;
  reflex: SingleSavingThrow;
  will: SingleSavingThrow;
}

export interface ResistanceValue {
  base: number;
  customMod: number;
}

export type DamageReductionTypeValue = string; // From JSON
export type DamageReductionRuleValue = string; // From JSON

export interface DamageReductionInstance {
  id: string;
  value: number;
  type: DamageReductionTypeValue | string;
  rule: DamageReductionRuleValue;
  isGranted?: boolean;
  source?: string;
}

export interface SpeedDetails {
  base: number;
  miscModifier: number;
}

export type CharacterSize =
  | "fine" | "diminutive" | "tiny" | "small" | "medium" | "large" | "huge" | "gargantuan" | "colossal" | '';

export type CharacterAlignment =
  | "lawful-good" | "neutral-good" | "chaotic-good"
  | "lawful-neutral" | "true-neutral" | "chaotic-neutral"
  | "lawful-evil" | "neutral-evil" | "chaotic-evil" | '';

export type DndRaceId = string;
export type DndClassId = string;
export type DndDeityId = string;
export type GenderId = string;
export type LanguageId = string;

export interface LanguageOption {
  value: LanguageId;
  label: string;
}

export interface CharacterSizeObject {
  value: CharacterSize;
  label: string;
  acModifier: number;
  skillModifiers?: Record<string, number>;
  grappleDamage?: string;
}

export interface CharacterAlignmentObject {
  value: CharacterAlignment;
  label: string;
  description: string;
}

export interface ClassCastingDetails {
  type: 'full' | 'partial' | 'none';
  startsAtLevel?: number;
  levelOffset?: number;
}
export interface DndRaceOption {
  value: DndRaceId;
  label: string;
  description?: string;
  bonusFeatSlots?: number;
  racialSkillBonuses?: Record<string, number>; // skillId: bonus
  grantedFeats?: Array<{ featId: string; note?: string; name?: string; levelAcquired?: number }>;
  speeds?: Partial<Record<SpeedType, number>>;
  automaticLanguages?: LanguageId[];
}
export interface DndClassOption {
  value: DndClassId | string;
  label: string;
  hitDice: string;
  description: string;
  casting?: ClassCastingDetails;
  grantedFeats?: Array<{ featId: string; note?: string; name?: string; levelAcquired?: number }>;
  saves?: {
    fortitude: "good" | "poor";
    reflex: "good" | "poor";
    will: "good" | "poor";
  };
}
export interface DndDeityOption {
  value: DndDeityId | string;
  label: string;
  alignment: CharacterAlignment;
  description?: string;
}

export interface SkillDefinitionJsonData {
  value: string;
  label: string;
  keyAbility: AbilityName | string;
  description?: string;
}

export type ClassSkillsJsonData = Record<string, string[]>;
export type ClassSkillPointsBaseJsonData = Record<string, number>;
export type SynergyEffectJsonData = { targetSkill: string; ranksRequired: number; bonus: number };
export type SkillSynergiesJsonData = Record<string, SynergyEffectJsonData[]>;


export interface Character {
  id: string;
  name: string;
  playerName?: string;
  campaign?: string;
  homeland?: string;
  race: DndRaceId | '';
  alignment: CharacterAlignment;
  deity?: DndDeityId | string;
  size: CharacterSize;
  age: number;
  gender: GenderId | string | '';
  height?: string;
  weight?: string;
  eyes?: string;
  hair?: string;
  skin?: string;
  languages?: LanguageId[];
  abilityScores: AbilityScores;
  abilityScoreTempCustomModifiers: AbilityScores;
  hp: number;
  maxHp: number;
  armorBonus: number;
  shieldBonus: number;
  sizeModifierAC: number;
  naturalArmor: number;
  deflectionBonus: number;
  dodgeBonus: number;
  acMiscModifier: number;
  babMiscModifier: number;
  initiativeMiscModifier: number;
  grappleMiscModifier: number;
  grappleWeaponChoice: string;
  grappleDamage_baseNotes: string;
  grappleDamage_bonus: number;
  savingThrows: SavingThrows;
  classes: CharacterClass[];
  skills: Skill[];
  feats: CharacterFeatInstance[];
  inventory: Item[];
  personalStory?: string;
  portraitDataUrl?: string;
  fireResistance: ResistanceValue;
  coldResistance: ResistanceValue;
  acidResistance: ResistanceValue;
  electricityResistance: ResistanceValue;
  sonicResistance: ResistanceValue;
  spellResistance: ResistanceValue;
  powerResistance: ResistanceValue;
  damageReduction: DamageReductionInstance[];
  fortification: ResistanceValue;
  landSpeed: SpeedDetails;
  burrowSpeed: SpeedDetails;
  climbSpeed: SpeedDetails;
  flySpeed: SpeedDetails;
  swimSpeed: SpeedDetails;
  armorSpeedPenalty_base: number;
  armorSpeedPenalty_miscModifier: number;
  loadSpeedPenalty_base: number;
  loadSpeedPenalty_miscModifier: number;
}

// Informational/Breakdown types
export type ResistanceFieldKeySheet = Exclude<keyof Pick<Character,
  'fireResistance' | 'coldResistance' | 'acidResistance' | 'electricityResistance' | 'sonicResistance' |
  'spellResistance' | 'powerResistance' | 'fortification'
>, 'damageReduction'>;

export type SpeedType = 'land' | 'burrow' | 'climb' | 'fly' | 'swim';

export type InfoDialogContentType =
  | { type: 'race' }
  | { type: 'class' }
  | { type: 'alignmentSummary' }
  | { type: 'deity' }
  | { type: 'abilityScoreBreakdown'; abilityName: Exclude<AbilityName, 'none'> }
  | { type: 'skillModifierBreakdown'; skillId: string }
  | { type: 'resistanceBreakdown'; resistanceField: ResistanceFieldKeySheet }
  | { type: 'acBreakdown'; acType: 'Normal' | 'Touch' | 'Flat-Footed' }
  | { type: 'babBreakdown' }
  | { type: 'initiativeBreakdown' }
  | { type: 'grappleModifierBreakdown' }
  | { type: 'grappleDamageBreakdown' }
  | { type: 'speedBreakdown'; speedType: SpeedType }
  | { type: 'armorSpeedPenaltyBreakdown' }
  | { type: 'loadSpeedPenaltyBreakdown' }
  | { type: 'genericHtml'; title: string; content: string };

export interface SkillDefinitionForDisplay {
  id: string;
  name: string;
  keyAbility: AbilityName;
  description?: string;
  isCustom: boolean;
  providesSynergies?: CustomSynergyRule[];
}

export interface AbilityScoreComponentValue {
  source: string;
  value: number;
  condition?: string; // Added to show conditional nature in breakdown
}
export interface AbilityScoreBreakdown {
  ability: Exclude<AbilityName, 'none'>;
  base: number;
  components: AbilityScoreComponentValue[];
  finalScore: number;
}
export type DetailedAbilityScores = Record<Exclude<AbilityName, 'none'>, AbilityScoreBreakdown>;


export interface AggregatedFeatEffects {
  skillBonuses: Record<string, number>; // skillId: totalBonus
  abilityScoreBonuses: AbilityScoreEffect[]; // Array of all ability score effects from feats
  // Initialize other aggregated fields here if they were defined in AggregatedFeatEffects
  // For now, it's just skillBonuses based on the current plan
  // In future iterations:
  // hpBonus: number,
  // initiativeBonus: number,
  // acBonuses: [],
  // savingThrowBonuses: { fortitude: 0, reflex: 0, will: 0, all: 0 },
  // attackRollBonuses: [],
  // damageRollBonuses: [],
  // etc.
  // FOR NOW, an example of how other fields might be structured.
  // We will only implement skillBonuses and abilityScoreBonuses for this step.
  savingThrowBonuses?: Array<SavingThrowEffect>;
  attackRollBonuses?: Array<AttackRollEffect>;
  damageRollBonuses?: Array<DamageRollEffect>;
  acBonuses?: Array<ArmorClassEffect>;
  hpBonus?: number;
  initiativeBonus?: number;
  speedBonuses?: Array<SpeedEffect>;
  resistanceBonuses?: Array<ResistanceEffect>;
  casterLevelCheckBonuses?: Array<CasterLevelCheckEffect>;
  spellSaveDcBonuses?: Array<SpellSaveDcEffect>;
  turnUndeadBonuses?: Array<TurnUndeadEffect>;
  grantedAbilities?: Array<GrantsAbilityEffect>;
  modifiedMechanics?: Array<ModifiesMechanicEffect>;
  proficienciesGranted?: Array<GrantsProficiencyEffect>;
  bonusFeatSlots?: Array<BonusFeatSlotEffect>;
  languagesGranted?: {
      count: number;
      specific: Array<{ languageId: LanguageId; note?: string; sourceFeat: string }>;
      note?: string;
  };
  descriptiveNotes?: Array<{ text: string; sourceFeat: string }>;
}


// Specific Effect Detail Types for future use (many are placeholders for now)
export interface SavingThrowEffect {
  type: "savingThrow";
  save: SavingThrowType | "all";
  value: number;
  bonusType?: "resistance" | "luck" | "morale" | "competence" | "circumstance" | "racial" | "untyped";
  condition?: string;
  sourceFeat?: string;
}

export interface AttackRollEffect {
  type: "attackRoll";
  value: number;
  bonusType?: string;
  appliesTo: "all" | "melee" | "ranged" | `weapon:${string}` | `weaponCategory:${string}` | "unarmed" | "grapple" | "SPEC";
  weaponTypes?: Array<"slashing" | "piercing" | "bludgeoning" | "unarmed" | "specificWeapon">;
  condition?: string;
  rangeLimit?: number;
  sourceFeat?: string;
}

export interface DamageRollEffect {
  type: "damageRoll";
  value: number | string;
  bonusType?: string;
  appliesTo?: "all" | "melee" | "ranged" | `weapon:${string}` | `weaponCategory:${string}` | "unarmed" | "grapple" | "SPEC";
  weaponTypes?: Array<"slashing" | "piercing" | "bludgeoning" | "unarmed" | "specificWeapon">;
  condition?: string;
  rangeLimit?: number;
  damageMultiplier?: number;
  sourceFeat?: string;
}

export interface ArmorClassEffect {
  type: "armorClass";
  value: number | "WIS" | "INT" | "CHA";
  acType: "dodge" | "armor" | "shield" | "natural" | "deflection" | "insight" | "circumstance" | "untyped" | "monk";
  bonusType?: string;
  condition?: string;
  appliesToScope?: ("normal" | "touch" | "flatFooted")[];
  maxDexBonus?: number | "unlimited";
  sourceFeat?: string;
}

export interface HitPointsEffect {
  type: "hitPoints";
  value: number;
  perLevel?: boolean;
  bonusType?: "untyped";
  sourceFeat?: string;
}

export interface InitiativeEffect {
  type: "initiative";
  value: number;
  bonusType?: "competence" | "insight" | "untyped";
  condition?: string;
  sourceFeat?: string;
}

export interface SpeedEffect {
  type: "speed";
  speedType: SpeedType | "all";
  modification: "bonus" | "setAbsolute" | "penalty";
  value: number;
  bonusType?: "enhancement" | "untyped";
  condition?: string;
  sourceFeat?: string;
}

export interface ResistanceEffect {
  type: "resistance";
  resistanceTo: string;
  value: number;
  isDamageReduction?: boolean;
  bypassedBy?: string[];
  bonusType?: "resistance" | "untyped";
  condition?: string;
  sourceFeat?: string;
}

export interface CasterLevelCheckEffect {
  type: "casterLevelCheck";
  value: number;
  forEvent?: "spellResistance" | "dispel" | "all";
  condition?: string;
  bonusType?: "untyped" | "competence";
  sourceFeat?: string;
}

export interface SpellSaveDcEffect {
  type: "spellSaveDc";
  school?: string | "all" | "SPEC";
  value: number;
  condition?: string;
  bonusType?: "untyped";
  sourceFeat?: string;
}

export interface TurnUndeadEffect {
  type: "turnUndead";
  property: "attempts" | "effectiveLevel" | "damage" | "checkBonus";
  value: number;
  bonusType?: "untyped";
  condition?: string;
  sourceFeat?: string;
}

export interface GrantsAbilityEffect {
  type: "grantsAbility";
  abilityKey: string;
  name: string;
  details?: string;
  uses?: { per: "day" | "encounter"; value: number | "levelBased" | "abilityModBased"; basedOnAbility?: Exclude<AbilityName, 'none'> };
  actionType?: "standard" | "move" | "fullRound" | "free" | "swift" | "immediate" | "reaction" | "passive";
  sourceFeat?: string;
}

export interface ModifiesMechanicEffect {
  type: "modifiesMechanic";
  mechanicKey: string;
  change: string;
  details?: string;
  value?: number | string;
  condition?: string;
  sourceFeat?: string;
}

export interface GrantsProficiencyEffect {
  type: "grantsProficiency";
  proficiencyType: "weapon" | "armor" | "shield";
  itemCategory?: "simple" | "martial" | "exotic" | "light" | "medium" | "heavy" | "tower";
  specificItem?: string;
  sourceFeat?: string;
}

export interface BonusFeatSlotEffect {
  type: "bonusFeatSlot";
  category: string;
  count: number;
  note?: string;
  condition?: string;
  sourceFeat?: string;
}

export interface LanguageEffect {
  type: "language";
  count?: number;
  specific?: LanguageId;
  note?: string;
  sourceFeat?: string;
}

export interface DescriptiveEffectDetail { // Renamed to match other effect details
  type: "descriptive";
  text: string;
  sourceFeat?: string;
}

// The main union type for all possible structured feat effects
export type StructuredFeatEffect =
  | SkillEffectDetail
  | NoteEffectDetail
  | AbilityScoreEffect // Added
  | SavingThrowEffect
  | AttackRollEffect
  | DamageRollEffect
  | ArmorClassEffect
  | HitPointsEffect
  | InitiativeEffect
  | SpeedEffect
  | ResistanceEffect
  | CasterLevelCheckEffect
  | SpellSaveDcEffect
  | TurnUndeadEffect
  | GrantsAbilityEffect
  | ModifiesMechanicEffect
  | GrantsProficiencyEffect
  | BonusFeatSlotEffect
  | LanguageEffect
  | DescriptiveEffectDetail; // Changed from DescriptiveEffect


export interface BabBreakdownDetails {
  baseBabFromClasses: number[];
  featAttackBonus: number; // From AggregatedFeatEffects
  miscModifier: number;
  totalBab: number[];
  characterClassLabel?: string;
}
export interface InitiativeBreakdownDetails {
  dexModifier: number;
  featBonus: number; // From AggregatedFeatEffects
  miscModifier: number;
  totalInitiative: number;
}
export interface GrappleModifierBreakdownDetails {
  baseAttackBonus: number;
  strengthModifier: number;
  sizeModifierGrapple: number;
  featBonus: number; // From AggregatedFeatEffects
  miscModifier: number;
  totalGrappleModifier: number;
}
export interface GrappleDamageBreakdownDetails {
  baseDamage: string; // e.g., "1d3"
  strengthModifier: number;
  featBonus: number; // From AggregatedFeatEffects
  bonus: number; // Misc/custom bonus
}
export interface SpeedComponent {
  source: string;
  value: number | string;
}
export interface SpeedBreakdownDetails {
  name: string;
  components: SpeedComponent[];
  total: number;
}

export interface PrerequisiteMessage {
  text: string;
  isMet: boolean;
  orderKey: string;
  originalText?: string;
}
